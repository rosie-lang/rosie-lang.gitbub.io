---
layout: post
title:  "Rosie v1.0 Preview #5: Looking Inside the Box (Debugging)"
date:   2017-08-12
categories: preview
---


1) More on debugging later (repl)
2) Start with full image
3) Then show the parts
4) Somewhere, note what ~ means

## Debugging is hard

Regex are hard to debug when they fail to match what you think they should match
(and vice versa).  That's why there are so many websites offering regex
debugging tools.  Rosie expressions can likewise be hard to debug, and I think
for the same reason: Pattern matchers (parsers, generally) are stateful
algorithms that can have a very large number of states, so there are many ways
that a human being's mental model of the situation can be wrong.

Plus, debugging any program can be hard!

Rosie provides a number of features that aid debugging, including:
* Symbols: Patterns have names, so symbolic debugging is possible
* Compositon: Patterns are composed from other patterns, enabling _divide and
  conquer_, where you separately test the pieces that make up your pattern
* Built-in tests: You can optionally declare tests in your comments, and Rosie
  will execute them, helping to find errors early (and to understand the
  author's intention of what was supposed to match and what wasn't)
* Read-eval-print loop: Rosie's repl let's you build up patterns interactively,
  and test against real data
* Trace command: It's easy to peek inside the Rosie pattern engine to see
  exactly how your pattern is being applied to your input

The read-eval-print loop of Rosie version 1.0 will be the subject of a future
blog post.  (You can read about the existing repl in,
e.g. [this blog post](https://developer.ibm.com/open/2016/10/14/develop-test-rosie-pattern-language-patterns-part-2-csv-data/)). 

In this post, we will take a very quick look at the `trace` command, which works
just like Rosie's `match` command, except it outputs a trace of the matching
process in the form of a tree (reflecting how patterns are composed from other
patterns).

Here is an example in which Rosie's `date.any` pattern fails to match "12
Agosto 2017", and how we might discover that "Agosto" is not one of the month
names defined in the `date` package.  

<img
class="pure-img displayed"
src="{{ site.baseurl }}/images/MyGrepIsAwesome-5-full.png" 
alt= "The screen capture shows the unix date command being piped into rosie,
where the rosie command is to match 'date.any'.  It matches.  Next, the command
'date -R' is piped into rosie, and it also matches.  Then, the string '12 Agosto
2017' is echoed into rosie, and it fails to match the pattern 'date.any'.
To find out why the match failed, the same command is executed again, with the
rosie command 'trace' instead of 'match'.  The output is a tree that shows each
component of 'date.any' and how each alternative matched (partially), so the
user can see exactly what part of the pattern failed, and where it failed on the
input string '12 Agosto 2017'.  It fails when the pattern 'month_name' fails to
match 'Agosto'."
/>


## Using the `match` command

The Rosie CLI can be used the way grep is used, to quickly find information in
files.  And like most unix tools, Rosie can read from standard input (which
requires a single dash "-" in place of the filename argument).

So we can pipe the output of the unix `date` command into Rosie as shown below.
On OS X and Linux, `date -R` will print the date in the RFC 5322 format, long
known as the RFC 2822 Internet Messaging format.

Naturally, we can also `echo` sample input and pipe that into Rosie:

<img
class="pure-img displayed"
src="{{ site.baseurl }}/images/MyGrepIsAwesome-5-1.png" 
alt= "The screen capture shows the unix date command being piped into rosie,
where the rosie command is to match 'date.any'.  It matches.  Next, the command
'date -R' is piped into rosie, and it also matches.  Then, the string '12 Agosto
2017' is echoed into rosie, and it fails to match the pattern 'date.any'."
/>

Note: We are only parsing the date in these examples, not the entire timestamp,
in order to keep the examples short.

The first 3 commands above succeeded, which we can see because the date was
printed by Rosie (and printed in blue, the default color for dates and times in
Rosie).  If we had added `-o json` to the commands, we would have seen that "Sat
Aug 12" matched `date.us`; "Sat, 12 Aug 2017" matched `date.rfc2822`, and "12
August 2017" also matched `date.rfc2822`.

The last command in the transcript above failed (there was no output).  The
input was "12 Agosto 2017".  Let's see how exactly it failed by changing the
command `match` to `trace`.


## Using the `trace` command




<img
class="pure-img displayed"
src="{{ site.baseurl }}/images/MyGrepIsAwesome-5-2.png" 
alt= 
"This screen capture shows the same output of the 'trace' command from the other
screen captures in this blog post.  The focus here is on the part of the trace
that steps through the definition of 'date.any'.  The trace shows that the
definition is 6 alternatives, and that each alternative failed.  They are:
'date.us', 'date.eur', 'date.dashed', 'date.slashed', 'date.rfc2822', and 'date.rfc3339'."
/>




<img
class="pure-img displayed"
src="{{ site.baseurl }}/images/MyGrepIsAwesome-5-3.png" 
alt= 
"This screen capture shows the same output of the 'trace' command from the other
screen captures in this blog post.  The focus here is on the part of the trace
that steps through the definition of 'date.rfc2822', which is one of the
alternative patterns in 'date.any'.  It fails when the pattern 'month_name' fails to
match 'Agosto'."
/>





## Rosie was created for scalable pattern matching

Scalability goals for Rosie include big data, large (complex) patterns, and many
developers.  Pre-compilation and built-in executable tests are steps towards
those goals.  They are steps towards bringing the tools and techniques we use in
general programming to the patterns we write to process raw data.

Pre-compilation and built-in testing are key parts of 
#[modernpatternmatching](https://twitter.com/search?q=%23modernpatternmatching).

<hr>

[1] Spishak, Dietl, and Ernst, "A type system for regular expressions".
In _Proceedings of the 14th Workshop on Formal Techniques for Java-like
Programs_, [ECOOP 2012](http://ecoop12.cs.purdue.edu)

[2] The `rosie test` command is implemented in a working prototype in branch
`tranche-3` of
[the Rosie Pattern Language repository on github](https://github.com/jamiejennings/rosie-pattern-language). This
prototype is evolving by steps to become release v1.0.0.

<hr>

Follow us on [Twitter](https://twitter.com/jamietheriveter) for
announcements.  We expect v1.0.0 to be released late this summer.


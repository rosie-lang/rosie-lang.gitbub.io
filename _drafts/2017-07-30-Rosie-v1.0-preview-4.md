---
layout: post
title:  "Rosie v1.0 Preview #4: Built-in Test Framework"
date:   2017-07-28
categories: preview
---

Everyone makes mistakes when entering regular expressions at the command line.
And, sometimes, an error occurs in a regular expression that is part of a
program.  Often those errors are not caught at compile time --- but of course we
*want* to catch as many errors as we can at compile time.

When a regex appears as a string in a Java program, as it might in other
languages, the Java compiler doesn't understand that the string is a regex, and
can't check it for mistakes that will throw run-time exceptions later.

One analysis found 56 regex syntax errors in an examination of five open source
Java projects.[1]  These projects would compile and run, but eventually, when
the offending regex was used, it would throw a `PatternSyntaxException` or an
`IndexOutOfBoundsException`.

The researchers that did the analysis proposed a solution for Java using
annotations, but generalizing this approach is fraught.  First, it's possible to
find and analyze string constants, but much harder to analyze strings that have
been manipulated via string operations, like concatenation and substitution.
Second, an approach that works for Java may not port easily to other, more
dynamic languages.

Rosie Pattern Language (RPL) patterns, by contrast, can be pre-compiled and
automatically tested, to find errors at compile time.  Here's an example of the
`rosie test` command:

<img
class="pure-img displayed"
src="{{ site.baseurl }}/images/MyGrepIsAwesome-3-execution.png" 
alt= "The screen capture shows the command 'rosie test rpl/*.rpl'.  The output
of that command is several lines, each of which is the file name, such as
'date.rpl', followed by the number of pattern tests that passed or failed.  One
file failed to compile, and the error message about an unbound variable is shown."
/>

## RPL patterns can be pre-compiled

RPL definitions can be (optionally) pre-compiled to find errors before
deployment.  Mistakes related to numbered captures are not possible in RPL, and
syntax errors are caught by the RPL compiler.  (A linter is on the drawing board
to detect subtle errors, and it's even possible to evaluate tests for "pattern
coverage".)

The image above shows the `rosie test` command in action, compiling a directory
of RPL files (and running embedded tests --- more on that in a minute).

You can, of course, put RPL expressions directly into large programs or small
scripts, as string literals.  But for production use, you can move those
expressions into their own file.  Rosie can then pre-compile your patterns as
part of your build, when other code is compiled, thereby catching errors at
compile time, not later at run time.

This is the classic "shift left" concept of catching errors early, as
popularized by the recent DevOps trend.  And, Rosie goes beyond pre-compilation
to include a lightweight test capability as well.

## Rosie has a built-in lightweight test facility







```
GREP_COLOR= tail /var/log/system.log | 
   GREP_COLOR='35' egrep --color=always 'apple|$' |
   GREP_COLOR='34' egrep -i --color=always 'syslogd|$' |
   GREP_COLOR='36' egrep --color=always 'launchd|$'
```

Simple, right?  It's just a matter of consulting the man pages, learning the
color codes, splitting up your regex, and doing some extra typing.  There is the
small matter of making sure that your regex patterns are disjoint.  In the
example above, the expressions are literals (apple, syslogd, and launchd) that
are clearly disjoint.

In other cases, it's not so obvious.  For example, the command below looks like
it should print ipv4 addresses in red (31) and domain names in yellow (33):

```
cat ~/Projects/rosie-pattern-language/test/resolv.conf | 
   GREP_COLOR='31' grep -E --color=always '(([0-9]{1,3})([.][0-9]{1,3}){3})|$' |
   GREP_COLOR='33' grep -E --color=always '(\w+([.]\w+)+)|$' 
```

But it fails, because the overly-general expression for domain names will also
match ipv4 addresses, leading to incorrect output.  (Note:  I did not have the
patience to add a third stage to the pipeline to match and print ipv6
addresses.  The example is messy enough as it is, and it's simpler than many
real-world use cases!)

## Rosie includes a lightweight pattern test capability

The figure below...


<br>

<img
class="pure-img displayed"
src="{{ site.baseurl }}/images/MyGrepIsAwesome-3-tests.png" 
alt= "A portion of a file of RPL code is shown, with pattern definitions for two
date formats, US and European.  Near each definition is a set of tests, written
as comments, which include example input text.  There are two kinds of tests:
Pattern X accepts input Y, and Pattern X rejects input Y."
/>

<br>





## Rosie was created for scalable pattern matching

Scalability goals for Rosie include big data, large (complex) patterns, and many
developers. 

...

That includes making it easy to visually confirm that you're getting the matches
you expect.  Rosie has a default set of colors assigned to many of the patterns
in its standard library, and you can customize those colors as you wish.

Solutions using grep/egrep are clumsy and error-prone.  First,
writing correct regex on the fly is hard.  It's better to have a library of
named patterns for common syntactic entities like network addresses, timestamps,
etc.  Second, it's hard to prove at a glance that a set of regular expressions
are disjoint, which makes it hard to write a correct pipeline that highlights
each pattern with a different color.

Last, I find that color output can be a great help when debugging a larger
solution (program or command line) that includes a pattern matching step.  That
is, I often want to run just the pattern matching step on some sample data and
look at the output.  With color match highlighting, I can see at a glance
whether I'm getting the matches I want.  But using color for debugging is pretty
hard to do if building the command line pipeline itself is
error-prone. <big> &#x2639;</big>


p

<br>

Pre-compilation and built-in testing are key parts of 
#[modernpatternmatching](https://twitter.com/search?q=%23modernpatternmatching).

<hr>

[1] Spishak, Dietl, and Ernst, "A type system for regular expressions".
In _Proceedings of the 14th Workshop on Formal Techniques for Java-like
Programs_, [ECOOP 2012](http://ecoop12.cs.purdue.edu)


<hr>

Follow us on [Twitter](https://twitter.com/jamietheriveter) for
announcements.  We expect v1.0.0 to be released late this summer.


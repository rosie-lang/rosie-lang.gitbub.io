---
layout: post
title:  "Rosie v1.0 Preview #4: Built-in Test Framework"
date:   2017-07-28
categories: preview
---



Think of your favorite regex tool.  How flexible is it when it comes to
producing output?

If your reflex is to reach for Perl, Python, or Ruby, you have infinite
possibilities at hand.  All you need to do is write some code.  Some scaffolding
to read the input, apply the pattern matching, and generate output in any format
you like.  It's a simple matter of programming.

If you reach for grep, you get pretty much just matching lines or matching text
output.  Although, you can get color-highlighted matches without any coding
--- but only in one color.  Of course, you can always build a little pipeline in
which each stage has an expression and a color, like this (with line breaks for
clarity): 

```
GREP_COLOR= tail /var/log/system.log | 
   GREP_COLOR='35' egrep --color=always 'apple|$' |
   GREP_COLOR='34' egrep -i --color=always 'syslogd|$' |
   GREP_COLOR='36' egrep --color=always 'launchd|$'
```

Simple, right?  It's just a matter of consulting the man pages, learning the
color codes, splitting up your regex, and doing some extra typing.  There is the
small matter of making sure that your regex patterns are disjoint.  In the
example above, the expressions are literals (apple, syslogd, and launchd) that
are clearly disjoint.

In other cases, it's not so obvious.  For example, the command below looks like
it should print ipv4 addresses in red (31) and domain names in yellow (33):

```
cat ~/Projects/rosie-pattern-language/test/resolv.conf | 
   GREP_COLOR='31' grep -E --color=always '(([0-9]{1,3})([.][0-9]{1,3}){3})|$' |
   GREP_COLOR='33' grep -E --color=always '(\w+([.]\w+)+)|$' 
```

But it fails, because the overly-general expression for domain names will also
match ipv4 addresses, leading to incorrect output.  (Note:  I did not have the
patience to add a third stage to the pipeline to match and print ipv6
addresses.  The example is messy enough as it is, and it's simpler than many
real-world use cases!)

## Rosie includes a lightweight pattern test capability

The figure below...


<img
class="pure-img displayed"
src="{{ site.baseurl }}/images/MyGrepIsAwesome-3-execution.png" 
alt= "The screen capture shows the command 'rosie test rpl/*.rpl'.  The output
of that command is several lines, each of which is the file name, such as
'date.rpl', followed by the number of pattern tests that passed or failed.  One
file failed to compile, and the error message about an unbound variable is shown."
/>

<br>

<img
class="pure-img displayed"
src="{{ site.baseurl }}/images/MyGrepIsAwesome-3-tests.png" 
alt= "A portion of a file of RPL code is shown, with pattern definitions for two
date formats, US and European.  Near each definition is a set of tests, written
as comments, which include example input text.  There are two kinds of tests:
Pattern X accepts input Y, and Pattern X rejects input Y."
/>

<br>





## Rosie was created for scalable pattern matching

Scalability goals for Rosie include big data, large (complex) patterns, and many
developers. 

...

That includes making it easy to visually confirm that you're getting the matches
you expect.  Rosie has a default set of colors assigned to many of the patterns
in its standard library, and you can customize those colors as you wish.

Solutions using grep/egrep are clumsy and error-prone.  First,
writing correct regex on the fly is hard.  It's better to have a library of
named patterns for common syntactic entities like network addresses, timestamps,
etc.  Second, it's hard to prove at a glance that a set of regular expressions
are disjoint, which makes it hard to write a correct pipeline that highlights
each pattern with a different color.

Last, I find that color output can be a great help when debugging a larger
solution (program or command line) that includes a pattern matching step.  That
is, I often want to run just the pattern matching step on some sample data and
look at the output.  With color match highlighting, I can see at a glance
whether I'm getting the matches I want.  But using color for debugging is pretty
hard to do if building the command line pipeline itself is
error-prone. <big> &#x2639;</big>




<br>

Output formats like color highlighting and JSON are how
#[modernpatternmatching](https://twitter.com/search?q=%23modernpatternmatching)
is done.



<hr>

Follow us on [Twitter](https://twitter.com/jamietheriveter) for
announcements.  We expect v1.0.0 to be released late this summer.


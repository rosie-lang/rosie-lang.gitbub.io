---
layout: post
title:  "Unicode predicates in RPL"
date:   2018-04-01
categories: 
---

Regex syntax has been extended over the years to allow matching of characters
based on their Unicode properties.  While there is considerable variation in the
syntax and the behavior across implementations, the Perl syntax may be familar.

> `\p{Lu}` matches a one codepoint in the Uppercase Letter category
> <br>`\P{script=greek}` matches one codepoint that is not in the Greek script

(If you are not familiar with Unicode, it will suffice for our purpose here to
treat _codepoint_ as a synonym for _character_.)

RPL already allows names to be bound to patterns, so there is no need to copy
the Perl syntax, or any of the others from other regex implementations.

## Unicode Predicates are in the Rosie Standard Library

In the RPL standard library are a set of files in the directory `rpl/Unicode`,
each of which defines a set of patterns corresponding to some Unicode property.
For example, `Script.rpl` defines `Script.Greek`, a pattern that matches a
single codepoint in the Greek script.

For example, in RPL we have:

> `Category.Lu` matches a one codepoint in the Uppercase Letter category
> <br>`{!Script.Greek .}` matches one codepoint that is not in the Greek script

To match a codepoint that is _not_ in the Greek script, we use the RPL operator `!`,
which means _not looking at_, and the pattern `.` which means _any character_.
Maybe we should add an operator (or macro) to RPL to shorten this expression?

Then again, a user can define their own shorthands as they wish.  In the rest of
the examples, the input file `sample.txt` contains:

>>    According to Google Translate, "Hello, world!" in Greek is "Γειά σου Κόσμε!".
>>    The same phrase in Hebrew is "שלום עולם!".


Here's an example of defining a shorthand, `NG`, for non-Greek words:

<style type="text/css">
<!--
  .bold {
	/* bold */
	font-weight: bold;
  }
  .comint-highlight-input {
	/* comint-highlight-input */
	font-weight: bold;
  }
  .comint-highlight-prompt {
	/* comint-highlight-prompt */
	color: #0000cd;
  }
  .comint-highlight-prompt {
	/* comint-highlight-prompt */
	color: #0000cd;
  }
  .custom {
	/* (foreground-color . "blue2") */
	color: #0000ee;
  }
  .custom-1 {
	/* (foreground-color . "cyan3") */
	color: #00cdcd;
  }
  .custom-2 {
	/* (foreground-color . "red3") */
	color: #cd0000;
  }
  .custom-3 {
	/* (foreground-color . "green3") */
	color: #00cd00;
  }
  .underline {
	/* underline */
	text-decoration: underline;
  }

  a {
	color: inherit;
	background-color: inherit;
	font: inherit;
	text-decoration: inherit;
  }
  a:hover {
	text-decoration: underline;
  }
-->
</style>

<pre>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Script; NG = {!Script.Greek .}+' --colors '*=red' -o color grep NG sample.txt</span>
<span class="custom-2">According to Google Translate, "Hello, world!" in Greek is "</span>&#915;&#949;&#953;&#940;<span class="custom-2"> </span>&#963;&#959;&#965;<span class="custom-2"> </span>&#922;&#972;&#963;&#956;&#949;<span class="custom-2">!".</span>
<span class="custom-2">The same phrase in Hebrew is "&#1513;&#1500;&#1493;&#1501; &#1506;&#1493;&#1500;&#1501;!".</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span>
</pre>

Definitions like `NG` in the example can be saved to a file that can be
loaded automatically by your `~/.rosierc` file.  Similarly, frequently used
libraries can be imported automatically in the same way.  

Also, note that the Rosie CLI auto-imports packages from the library path.  This
is how patterns like `net.ip` may be used without needing an `import` statement.
Currently, in the 1.0.0-beta release, the auto-import search looks only one
directory deep, so it will not find `Script.rpl` because that file is in the
subdirectory `Unicode`.  Perhaps we will enhance the CLI to search into
subdirectories? In that case, what should happen when two subdirectories have
packages with the same name?  Let us know what you think, on the
[Rosie subreddit](https://www.reddit.com/r/RosiePatternLanguage/). 

## Examples

In the transcript below are some examples of using Unicode predicates, the Rosie
match and grep commands, and custom color output.

<pre>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input"># Rosie's "grep" command outputs plain text by default</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Script' grep Script.Greek sample.txt</span>
According to Google Translate, "Hello, world!" in Greek is "&#915;&#949;&#953;&#940; &#963;&#959;&#965; &#922;&#972;&#963;&#956;&#949;!".
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input"># We can change the output to color, to see the Greek characters in bold (the default)</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Script' -o color grep Script.Greek sample.txt</span>
According to Google Translate, "Hello, world!" in Greek is "<span class="bold">&#915;&#949;&#953;&#940;</span> <span class="bold">&#963;&#959;&#965;</span> <span class="bold">&#922;&#972;&#963;&#956;&#949;</span>!".
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input"># And we can customize the color</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Script' -o color --colors 'Script.Greek=cyan;bold' grep Script.Greek sample.txt</span>
According to Google Translate, "Hello, world!" in Greek is "<span class="custom-1"><span class="bold">&#915;&#949;&#953;&#940;</span></span> <span class="custom-1"><span class="bold">&#963;&#959;&#965;</span></span> <span class="custom-1"><span class="bold">&#922;&#972;&#963;&#956;&#949;</span></span>!".
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input"># Of course, "grep" is shorthand for using "match" with the "findall" macro,</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input"># so we our last command is equivalent to this one:</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Script' --colors 'Script.Greek=cyan;bold' match findall:Script.Greek sample.txt</span>
According to Google Translate, "Hello, world!" in Greek is "<span class="custom-1"><span class="bold">&#915;&#949;&#953;&#940;</span></span> <span class="custom-1"><span class="bold">&#963;&#959;&#965;</span></span> <span class="custom-1"><span class="bold">&#922;&#972;&#963;&#956;&#949;</span></span>!".
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input"># Let's define pattern names (and colors) for Greek words and Hebrew words</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Script; H=Script.Hebrew+; G=Script.Greek+' --colors 'H=blue;underline:G=cyan;bold' match 'findall:(H/G)' sample.txt</span>
According to Google Translate, "Hello, world!" in Greek is "<span class="custom-1"><span class="bold">&#915;&#949;&#953;&#940;</span></span> <span class="custom-1"><span class="bold">&#963;&#959;&#965;</span></span> <span class="custom-1"><span class="bold">&#922;&#972;&#963;&#956;&#949;</span></span>!".
The same phrase in Hebrew is "<span class="custom"><span class="underline">&#1513;&#1500;&#1493;&#1501;</span></span> <span class="custom"><span class="underline">&#1506;&#1493;&#1500;&#1501;</span></span>!".
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input"># We can extract only the Hebrew and Greek words with the "subs" output format</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Script; H=Script.Hebrew+; G=Script.Greek+' -o subs match 'findall:(H/G)' sample.txt</span>
&#915;&#949;&#953;&#940; 
&#963;&#959;&#965; 
&#922;&#972;&#963;&#956;&#949;
&#1513;&#1500;&#1493;&#1501; 
&#1506;&#1493;&#1500;&#1501;
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input"># The "grep" command is a little simpler:</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Script; H=Script.Hebrew+; G=Script.Greek+' -o subs grep 'H/G' sample.txt</span>
&#915;&#949;&#953;&#940;
&#963;&#959;&#965;
&#922;&#972;&#963;&#956;&#949;
&#1513;&#1500;&#1493;&#1501;
&#1506;&#1493;&#1500;&#1501;
<span class="comint-highlight-prompt">$ </span></pre>


Here's another example, in which we match all the uppercase letters in the
sample input:

<pre>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Category' --colors '*=red' match 'findall:Category.Lu' sample.txt</span>
<span class="custom-2">A</span>ccording to <span class="custom-2">G</span>oogle <span class="custom-2">T</span>ranslate, "<span class="custom-2">H</span>ello, world!" in <span class="custom-2">G</span>reek is "<span class="custom-2">&#915;</span>&#949;&#953;&#940; &#963;&#959;&#965; <span class="custom-2">&#922;</span>&#972;&#963;&#956;&#949;!".
<span class="custom-2">T</span>he same phrase in <span class="custom-2">H</span>ebrew is "&#1513;&#1500;&#1493;&#1501; &#1506;&#1493;&#1500;&#1501;!".
<span class="comint-highlight-prompt">$ </span></pre>



<!-- From the -->
<!-- [Unicode Regular Expressions](https://unicode.org/reports/tr18/#Categories) -->
<!-- Technical Report... -->

<!-- | Possible regex                   | RPL (actual)             | Matches   | -->
<!-- | -------------------------------- | :----------------------: | :-------: | -->
<!-- | [\p{L} \p{Nd}]	               | Property.L / Property.Nd | all letters and decimal digits -->
<!-- | [\p{letter} \p{decimal number}]  | _"_                      | _"_          -->
<!-- | [\p{letter\|decimal number}]     | _"_                      | _"_     -->
<!-- | [\p{L\|Nd}]                      | _"_                      | _"_          -->
<!-- | \P{script=greek}                 | {! Script.Greek .}       | anything that does not have the Greek script -->
<!-- | \P{script:greek}                 | _"_                      | _"_     -->
<!-- | \p{script≠greek}                 | _"_                      | _"_     -->
<!-- | [:^script=greek:]                | _"_                      | _"_     -->
<!-- | [:^script:greek:]                | _"_                      | _"_     -->
<!-- | [:script≠greek:]                 | _"_                      | _"_     -->
<!-- | \p{Whitespace}	               | Property.White_Space     | anything that has binary property value Whitespace = True -->



## Using Unicode Predicates Inside RPL Character Classes

RPL character class syntax resembles regex character class syntax, but is more,
well, *regular*.  A simple character class is enclosed in brackets and is only
one of:
* a range, like `[A-Z]`, or its complement `[^A-Z]`
* a set, like `[abc]`, or its complement `[^abc]`
* a Posix named set, like `[:digit:]`, or its complement `[:^digit:]`

Compound character sets in RPL are made by enclosing simple character sets in
brackets, such as:
* `[[A-Z] [abc]]` which matches A through Z as well as a, b, or c
* `[^ [A-Z] [:digit:] ]` which matches a character that is _not_ in A-Z and
  _not_ a digit
  
Our earlier post on [RPL Character Sets]({{ site.baseurl }}{% post_url
2018-01-08-RPL-Character-Sets %}) describes the design, rationale, and
capabilities in more detail.  An important decision was to allow RPL pattern
names inside a compound character set.

A compound character set is defined by brackets enclosing one or more simple
sets, so we must include a simple character set, even an empty one, if we want
to use an RPL pattern name inside a character set.  For example:

<p>
<pre>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Script' grep -o color 'Script.Greek' sample.txt</span>
According to Google Translate, "Hello, world!" in Greek is "<span class="bold">&#915;&#949;&#953;&#940;</span> <span class="bold">&#963;&#959;&#965;</span> <span class="bold">&#922;&#972;&#963;&#956;&#949;</span>!".
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Script' grep -o color '{!Script.Greek .}' sample.txt</span>
<span class="bold">According to Google Translate, "Hello, world!" in Greek is "</span>&#915;&#949;&#953;&#940;<span class="bold"> </span>&#963;&#959;&#965;<span class="bold"> </span>&#922;&#972;&#963;&#956;&#949;<span class="bold">!".</span>
<span class="bold">The same phrase in Hebrew is "&#1513;&#1500;&#1493;&#1501; &#1506;&#1493;&#1500;&#1501;!".</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Script' grep -o color '[^[] Script.Greek]' sample.txt</span>
<span class="bold">According to Google Translate, "Hello, world!" in Greek is "</span>&#915;&#949;&#953;&#940;<span class="bold"> </span>&#963;&#959;&#965;<span class="bold"> </span>&#922;&#972;&#963;&#956;&#949;<span class="bold">!".</span>
<span class="bold">The same phrase in Hebrew is "&#1513;&#1500;&#1493;&#1501; &#1506;&#1493;&#1500;&#1501;!".</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Script' grep -o color --colors '*=green' '[^[] Script.Greek]' sample.txt</span>
<span class="custom-3">According to Google Translate, "Hello, world!" in Greek is "</span>&#915;&#949;&#953;&#940;<span class="custom-3"> </span>&#963;&#959;&#965;<span class="custom-3"> </span>&#922;&#972;&#963;&#956;&#949;<span class="custom-3">!".</span>
<span class="custom-3">The same phrase in Hebrew is "&#1513;&#1500;&#1493;&#1501; &#1506;&#1493;&#1500;&#1501;!".</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span>
</pre></p>


## Limitations

Some Unicode properties are not yet supported by RPL, such as `East Asian
Width`.  We will add the remaining Unicode properties to the Rosie Standard
Library. 

Today, the Unicode Derived Properties are not included in the RPL library.
These are property names like `Lowercase`, which is defined as the union of `Ll`
and `Other_Lowercase`.  Similarly, the Unicode specification defines the
Category `L` and its alias `Letter` to be the disjunction `Lu | Ll | Lt | Lm |
Lo`.

Property aliases are not yet supported. For example, today you write
`Category.Lu` for upper case letters, but in the future, when Unicode aliases
are supported, you will be able to write `Category.Uppercase_Letter` instead, if
you wish.  


## Additions

The Posix character sets are defined in terms of the ASCII character set (and
encoding).  In RPL, as in regex, they are written like `[:alpha:]`.  The same
names are defined in the RPL library `Unicode/Ascii` (in the file `rpl/Unicode/Ascii.rpl`).

<pre>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">rosie --rpl 'import Unicode/Ascii' --colors '*=red' match 'findall:Ascii.alpha' sample.txt</span>
<span class="custom-2">According</span> <span class="custom-2">to</span> <span class="custom-2">Google</span> <span class="custom-2">Translate</span>, "<span class="custom-2">Hello</span>, <span class="custom-2">world</span>!" <span class="custom-2">in</span> <span class="custom-2">Greek</span> <span class="custom-2">is</span> "&#915;&#949;&#953;&#940; &#963;&#959;&#965; &#922;&#972;&#963;&#956;&#949;!".
<span class="custom-2">The</span> <span class="custom-2">same</span> <span class="custom-2">phrase</span> <span class="custom-2">in</span> <span class="custom-2">Hebrew</span> <span class="custom-2">is</span> "&#1513;&#1500;&#1493;&#1501; &#1506;&#1493;&#1500;&#1501;!".
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span>
</pre>


## Goals

I'll conclude this post with a brief summary of the goals we had in designing
our Unicode predicate support.

- Support all Unicode properties and property values that are useful for matching.
- Support the latest and future Unicode standards (modulo structural changes to
  the standard) by automating the generation of RPL patterns from the Unicode
  Character Database.
- Allow Unicode and other named patterns to be used within a compound character
 set.
- Support union, intersection, and difference operations between character
  sets.  See [RPL Character Sets]({{ site.baseurl }}{% post_url
2018-01-08-RPL-Character-Sets %}).
- Stay consistent with the RPL design, avoiding cryptic syntax as much as possible, and also
  avoiding ambiguity, both perceived and actual.

RPL will never be as concise as regex.  Indeed, a major objective in designing
RPL was to make pattern expressions easier to understand.  Having full names and
allowing whitespace helps that goal, while requiring a little more typing.

At the command line, we do some things to simplify using Rosie, like
auto-import and reading a `~/.rosierc` file.  But we can do more.
Auto-importing can search more extensively, for instance.  

And we could supply in the standard library a set of short names for patterns
that have long names.  Then again, users can do this for themselves, and we hope
they will, and that they will post their personal libraries of abbreviations!


## Discussion on reddit

A [Rosie subreddit](https://www.reddit.com/r/RosiePatternLanguage/) has been
created for discussion of these posts and for questions about Rosie and RPL.
See you there!

<hr>

Follow us on [Twitter](https://twitter.com/jamietheriveter) for announcements
about the RPL approach to #[modernpatternmatching](https://twitter.com/search?q=%23modernpatternmatching).




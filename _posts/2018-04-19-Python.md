---
layout: post
title:  "Using Rosie from Python"
date:   2018-04-19
categories: 
---

For some time, Rosie has had a Python module, but it was undocumented.  Until
now, you had to read the code to understand how to use it.  In this post, we'll
look at `rosie.py`, which exposes the Rosie Pattern Language functionality to
Python programmers.

## Install with pip

The easiest way to install Rosie for use with Python is simply:

    pip install rosie

Then, from within your Python program, you only need to import the rosie package
to get started:

    import rosie

As of this writing (April, 2018), you will get the latest beta version.
The installation consists mainly of `librosie`, `rosie.py`, and the standard
library of rpl patterns.  If there is a wheel for your platform, the install
will run quickly, simply copying a few files.  If not, then `pip` will download
the source distribution and build `librosie`, which requires cc/gcc and make.

This installation method puts a private copy of Rosie wherever your Python
modules are stored.  As a result, `pip uninstall rosie` will remove all traces
of the installation.

If you already have Rosie installed, you will now have two independent
installations.  However, you can call `rosie.load(path)` at the start of your
Python program to load the `librosie` that you have already installed (e.g. in
`/usr/local`).  Using `rosie.load()` is optional; without it, your Python code
will use the Rosie installation in your Python directory.

## Programming model

The programming model for using Rosie is similar to PCRE, RE2, and other pattern
matching libraries.  Roughly speaking, the steps are:

1. Create a _matching engine_
2. Optionally load some pattern definitions into the engine
3. Compile a pattern
4. Use the compiled pattern to match against input data

Here's an example (without any error checking):

	# matchall.py
	from __future__ import print_function
	import rosie, sys
	e = rosie.engine()
	e.import_pkg('all')
	pat, errs = e.compile('all.things')
	print(e.match(pat, sys.argv[1], 1, 'color')[0])

<style type="text/css">
    <!--
      body {
        color: #000000;
        background-color: #ffffff;
      }
      .bold {
        /* bold */
        font-weight: bold;
      }
      .comint-highlight-input {
        /* comint-highlight-input */
        font-weight: bold;
      }
      .comint-highlight-prompt {
        /* comint-highlight-prompt */
        color: #0000cd;
      }
      .comint-highlight-prompt {
        /* comint-highlight-prompt */
        color: #0000cd;
      }
      .custom {
        /* (foreground-color . "green3") */
        color: #00cd00;
      }
      .custom-1 {
        /* (foreground-color . "red3") */
        color: #cd0000;
      }
      .custom-2 {
        /* (foreground-color . "cyan3") */
        color: #00cdcd;
      }
      .custom-3 {
        /* (foreground-color . "blue2") */
        color: #0000ee;
      }
      .custom-4 {
        /* (foreground-color . "yellow3") */
        color: #cdcd00;
      }
      .underline {
        /* underline */
        text-decoration: underline;
      }

      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
<pre>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">python matchall.py 'Today is April 14, 2018.  IP 1.2.3.4; 1 mole = 6.02e23; www.ibm.com/a/b/c'</span>
<span class="custom-4">Today</span> <span class="custom-4">is</span> <span class="custom-3">April</span> <span class="custom-3">14</span>, <span class="custom-3">2018</span><span class="bold">.</span>  <span class="custom-2">IP </span><span class="custom-1">1.2.3.4</span><span class="bold">;</span> <span class="underline">1</span> <span class="custom-4">mole</span> <span class="bold">=</span> <span class="underline">6.02e23</span><span class="bold">;</span> <span class="custom-1">www.ibm.com</span><span class="custom">/a/b/c</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span>
</pre>

### Engines

In the example, `rosie.engine()` creates a _matching engine_.  You can create as
many engines as you want or need.  (They will be garbage collected when they are
no longer accessible.)

An engine's state includes a set of pattern definitions that have been loaded.
When you make a new engine, it has only a limited set of built-in patterns.

Components of an engine's state:

Name         |  Description                                          | Sample value
-------------|-------------------------------------------------------|----------------
Environment  | Patterns loaded (available for use)                   | `$`, `num.int`, `net.ipv4`
Library path | List of directories to search when importing          | `/usr/local/lib/rosie/rpl:~/rpl`
Colors       | Map from pattern names to colors for colorized output | `foo=green;bold`


### Examining and setting the environment

<img height="30px" src="{{ site.baseurl }}/images/todo.png" alt= "The adjacent text is labeled 'to do'."/>
`librosie` can tell you what patterns are loaded, but this API is not yet in
`rosie.py`.

New pattern definitions are added to the environment of an engine using the
`load` and `import_pkg` functions ([see below](#Loading_pattern_definitions)).

### Examining and setting the library path

The method `e.libpath()` returns the current library path.  When called with a
string argument, it sets the library path.  

The full configuration of an engine, including the library path, can be obtained
via `e.config()`, which returns a JSON encoding of two lists of configuration
objects.  The first list are settings of the Rosie installation, and the second
list are settings of this particular engine.

## Loading pattern definitions

There are three ways to load pattern definitions into a Rosie matching engine:
1. from a string
2. from an arbitrary file
3. by importing a package

API                | Argument           | Description
------------------ | ------------------ | -----------
`e.load(s)`        | Python _bytes_     | RPL statements, UTF-8 encoded in a byte array
`e.loadfile(fn)`   | Filename           | File of RPL statements (UTF-8)
`e.import_pkg(pn)` | Package name (e.g. `net`) | Name of a package on the `libpath`

The most common RPL statements bind expressions to a name, e.g.

    int = 0 / [1-9][0-9]*

A set of statements form a _block_, and a block can optionally include `import`
statements, a `package` declaration, and an `rpl` (language version)
declaration.

A block that includes a `package` declaration is, of course, a package.  Names
inside a package are referred to using the package name as a prefix,
e.g. `net.ipv4`.

When loading RPL from strings or files, the RPL statements may or may not form a
package.  When `import`ing a package, the file that implements the package must
declare the package name.  Rosie searches for packages in each directory on its
`libpath`.  The `libpath` of an engine can be changed at any time, and will
affect subsequent calls to `import_pkg`.


## Matching options

As we saw in the example at the start of the Programming Model section above,
the `match` method of an engine takes 4 arguments:
- a compiled pattern,
- the input data,
- a start position within the input data (1-based), and
- the choice of output encoding.

A compiled pattern is returned by the engine's `compile(exp)` method, where the
argument, `exp`, is a Python _bytes_ object encoding an RPL expression in
UTF-8.  In the example above, the expression is simply a reference to the
pattern `all.things`, which was already loaded (via `import_pkg`).

Some of the output encoding options are:

Output encoder | Returns
-------------- | ------------------
bool           | True if the pattern matched, and False otherwise
byte           | Byte array which compactly encodes a match
color          | String that may include [ANSI escape sequences](https://en.wikipedia.org/wiki/ANSI_escape_code)
json           | String encoding a match structure in JSON
jsonpp         | String encoding a match as pretty-printed JSON
line           | The input, if the pattern matched, and False otherwise
matches        | The portion of the input that matched
subs           | A linefeed-separated list of the submatches

Most of the output encoders were designed for the Rosie CLI, and in particular
for human consumption.  The formats most applicable for Python users are likely
to be:

Output encoder | Usage
-------------- | ------
json  | Decode with `json.loads()` or equivalent to obtain a match structure
bool  | Faster than `json` for when you want to know only if there was a match

<img height="30px" src="{{ site.baseurl }}/images/todo.png" alt= "The adjacent text is labeled 'to do'."/>
Matches encoded using the compact `byte` format are much smaller than their
`json` equivalent, and faster to decode.  We have not yet implemented a decoder
for Python, which would accept Rosie's `byte` format and return a match data
structure (a Python dictionary).  The format is simple ([here is a decoder in C
that produces a Lua table](https://github.com/jamiejennings/rosie-lpeg/blob/a84a89e50a74ac2554126aba37a202f326fdc645/src/lpcap.c#L617-L678))
and if someone wants to contribute a Python decoder, we'd appreciate it!


## Return values from match()

The full set of return values from `engine.match()` are:

Return value   | Description
-------------- | --------------
match          | `None` or a match structure (see [below](#The_match_structure))
leftover       | number of characters left unmatched (0 when entire input was matched)
abend          | 0 when matching ended abnormally via the RPL `error` macro
total time     | microseconds of processor time consumed by `match()` (see note below)
match time     | microseconds of processor time spent in the matching vm (see note below)

### Note about time values

The two time values returned by `match()` are a crude but useful measure of
performance.  The total time includes call overhead, matching, and encoding the
output.  The match time includes only the time spent in the matching vm, and is
therefore independent of the choice of output encoder.

**Important note:** The last step of RPL pattern compilation is code generation
for the matching vm, and it is performed the first time the pattern is used in
`match()`.  So the cost of the low-level code generation, which is done once per
pattern, is reflected in the match time _the first time a pattern is used_.
This is true for Rosie v1.0.0-beta, and may change in the future.

### The match structure

A Rosie match structure consists of the following fields:

Field name | Description
---------- | -----------
type       | the RPL pattern name that matched
data       | the input data that matched this pattern
s          | the start position of the match, a 1-based byte index
e          | the end position of the match (see note below)
subs       | `None` or a list of submatches, each of which is a match structure

**Note on start/end indices:** The end position, `e`, is the first byte of the
  first character after the match.  In other words, if `input` is a byte array
  holding the input data, then the match consists of the characters in the
  Python slice `input[s-1:e-1]`.  Note the adjustment to Python's 0-based
  indexing. 

**Note on the match data:** If the input data is valid UTF-8, then both `s` and
`e` will point to the first byte of a valid UTF-8 encoded character, and the
`data` field will be valid UTF-8.

**Python example:**
<pre>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">&gt;&gt;&gt; </span></span><span class="comint-highlight-input">d, err = e.compile('date.any')</span>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">&gt;&gt;&gt; </span></span><span class="comint-highlight-input">json.loads(e.match(d, datetime.datetime.now().isoformat(), 1, 'json')[0])</span>
{u'e': 11, u's': 1, u'type': u'date.any', u'subs': [{u'e': 11, u's': 1, u'type': u'date.dashed', u'subs': [{u'e': 5, u's': 1, u'type': u'date.year', u'data': u'2018'}, {u'e': 8, u's': 6, u'type': u'date.month', u'data': u'04'}, {u'e': 11, u's': 9, u'type': u'date.day', u'data': u'19'}], u'data': u'2018-04-19'}], u'data': u'2018-04-19'}
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">&gt;&gt;&gt; </span></span>
</pre>


**CLI example, for comparison:**
<pre>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">date | rosie match date.any</span>
<span class="custom-3">Thu</span> <span class="custom-3">Apr</span> <span class="custom-3">19</span> 05:42:01 EDT 2018
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">$ </span></span><span class="comint-highlight-input">date | rosie -o jsonpp match date.any</span>
{"type": "date.any", 
 "e": 12, 
 "s": 1, 
 "subs": 
   [{"type": "date.us_long", 
     "e": 12, 
     "s": 1, 
     "subs": 
       [{"type": "date.day_name", 
         "e": 4, 
         "s": 1, 
         "subs": 
           [{"type": "date.day_shortname", 
             "e": 4, 
             "s": 1, 
             "data": "Thu"}], 
         "data": "Thu"}, 
        {"type": "date.month_name", 
         "e": 8, 
         "s": 5, 
         "subs": 
           [{"type": "date.month_shortname", 
             "e": 8, 
             "s": 5, 
             "data": "Apr"}], 
         "data": "Apr"}, 
        {"type": "date.day", 
         "e": 11, 
         "s": 9, 
         "data": "19"}], 
     "data": "Thu Apr 19 "}], 
 "data": "Thu Apr 19 "}
<span class="comint-highlight-prompt">$ </span>
</pre>


## Debugging

Tools for debugging patterns include:
* the `trace` command of the CLI and the `.trace` command of the REPL
* the `trace()` method

The tracing capability prints out a graphical depiction of the matching process,
as shown in the example below.

<img height="30px" src="{{ site.baseurl }}/images/todo.png" alt= "The adjacent text is labeled 'to do'."/>
The trace data is available today in `full` and `condensed` formats, both of
which are strings suitable for printing, i.e. for human consumption.  Rosie is
capable of returning a JSON-encoded tree structure containing the trace data,
but the API to do this is not yet implemented.

<pre>
<span class="comint-highlight-prompt"><span class="comint-highlight-prompt">&gt;&gt;&gt; </span></span><span class="comint-highlight-input">print e.trace(d, datetime.datetime.now().isoformat(), 1, 'condensed')[1]</span>
Expression: {us / eur / dashed / slashed / rfc2822 / rfc3339 / spaced_en / spaced}
Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
Matched 10 chars
&#9500;&#9472;&#9472; Expression: us
&#9474;   Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;   No match
&#9474;   &#9492;&#9472;&#9472; Expression: {us_dashed / us_slashed / us_long / us_short}
&#9474;       Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;       No match
&#9474;       &#9500;&#9472;&#9472; Expression: us_dashed
&#9474;       &#9474;   Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;       &#9474;   No match
&#9474;       &#9474;   &#9492;&#9472;&#9472; Expression: {month "-" day "-" short_long_year}
&#9474;       &#9474;       Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;       &#9474;       No match
&#9474;       &#9474;       &#9500;&#9472;&#9472; Expression: month
&#9474;       &#9474;       &#9474;   Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;       &#9474;       &#9474;   Matched 1 chars
&#9474;       &#9474;       &#9474;   &#9492;&#9472;&#9472; Expression: &#124;&#124;"1" [0-2]} / &#124;&#124;"0"}? [1-9]}}
&#9474;       &#9474;       &#9474;       Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;       &#9474;       &#9474;       Matched 1 chars
&#9474;       &#9474;       &#9474;       &#9500;&#9472;&#9472; Expression: {"1" [0-2]}
&#9474;       &#9474;       &#9474;       &#9474;   Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;       &#9474;       &#9474;       &#9474;   No match
&#9474;       &#9474;       &#9474;       &#9474;   &#9500;&#9472;&#9472; Expression: "1"
&#9474;       &#9474;       &#9474;       &#9474;   &#9474;   Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;       &#9474;       &#9474;       &#9474;   &#9474;   No match
&#9474;       &#9474;       &#9474;       &#9474;   &#9492;&#9472;&#9472; Expression: [0-2]
&#9474;       &#9474;       &#9474;       &#9474;       Not attempted
&#9474;       &#9474;       &#9474;       &#9492;&#9472;&#9472; Expression: &#124;&#124;"0"}? [1-9]}
&#9474;       &#9474;       &#9474;           Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;       &#9474;       &#9474;           Matched 1 chars
&#9474;       &#9474;       &#9500;&#9472;&#9472; Expression: "-"
&#9474;       &#9474;       &#9474;   Looking at: &#12298;018-04-19T06:12:34.591774&#12299; (input pos = 2)
&#9474;       &#9474;       &#9474;   No match
&#9474;       &#9474;       &#9500;&#9472;&#9472; Expression: day
&#9474;       &#9474;       &#9474;   Not attempted
&#9474;       &#9474;       &#9500;&#9472;&#9472; Expression: "-"
&#9474;       &#9474;       &#9474;   Not attempted
&#9474;       &#9474;       &#9492;&#9472;&#9472; Expression: short_long_year
&#9474;       &#9474;           Not attempted
&#9474;       &#9500;&#9472;&#9472; Expression: us_slashed
&#9474;       &#9474;   Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;       &#9474;   No match
&#9474;       &#9500;&#9472;&#9472; Expression: us_long
&#9474;       &#9474;   Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;       &#9474;   No match
&#9474;       &#9492;&#9472;&#9472; Expression: us_short
&#9474;           Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;           No match
&#9500;&#9472;&#9472; Expression: eur
&#9474;   Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;   No match
&#9500;&#9472;&#9472; Expression: dashed
&#9474;   Looking at: &#12298;2018-04-19T06:12:34.591774&#12299; (input pos = 1)
&#9474;   Matched 10 chars
&#9500;&#9472;&#9472; Expression: slashed
&#9474;   Not attempted
&#9500;&#9472;&#9472; Expression: rfc2822
&#9474;   Not attempted
&#9500;&#9472;&#9472; Expression: rfc3339
&#9474;   Not attempted
&#9500;&#9472;&#9472; Expression: spaced_en
&#9474;   Not attempted
&#9492;&#9472;&#9472; Expression: spaced
    Not attempted
<span class="comint-highlight-prompt">&gt;&gt;&gt; </span>
</pre>

## Examples

A very simple example of using Rosie from Python is the program
[generic_sloc.py](https://github.com/jamiejennings/rosie-pattern-language/blob/master/extra/examples/generic_sloc.py)
in the Rosie
[examples directory on GitHub](https://github.com/jamiejennings/rosie-pattern-language/tree/master/extra/examples). 

Some of the examples from this post are also on github, in the [code/python]({{
site.baseurl }}/code/python) directory.


## A simpler API should wrap the current one

Today, `rosie.py` is low level and not very Pythonic.  It is important to expose
`librosie` functionality at a low level, so this is a good start.  However, we
need a layer on top of `rosie.py` that is easier to use.

I suspect that every Rosie + Python user has developed their own small interface layer
to suit their needs.  We would like to have a clean high-level interface for
general use.  If you are interested in contributing a layer over `rosie.py`,
please get in touch by email (link in side menu, at left)
or by opening a [GitHub issue](https://github.com/jamiejennings/rosie-pattern-language/issues).


## Discussion on reddit

A [Rosie subreddit](https://www.reddit.com/r/RosiePatternLanguage/) has been
created for discussion of these posts and for questions about Rosie and RPL.
See you there!

<hr>

Follow us on [Twitter](https://twitter.com/jamietheriveter) for announcements
about the RPL approach to #[modernpatternmatching](https://twitter.com/search?q=%23modernpatternmatching).



